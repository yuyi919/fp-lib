## API Report File for "@yuyi919/fp-lib"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as Functor from 'fp-ts/Functor';
import * as HKT from 'fp-ts/HKT';
import { identity } from 'fp-ts/function';
import * as identity_2 from 'fp-ts/Identity';
import { Kind } from 'fp-ts/HKT';
import { Kind2 } from 'fp-ts/HKT';
import { Kind3 } from 'fp-ts/HKT';
import * as MIO from 'fp-ts/IO';
import * as MR from 'fp-ts/Reader';
import { Predicate } from 'fp-ts/Predicate';
import { Refinement } from 'fp-ts/Refinement';
import { URIS } from 'fp-ts/HKT';
import { URIS2 } from 'fp-ts/HKT';
import { URIS3 } from 'fp-ts/HKT';

// @public (undocumented)
class AssertError extends Error {
    constructor(msg?: string);
}

// @public (undocumented)
const Asserts: AssertsT.AssertsT<"NonNullable">;

// @public (undocumented)
type AssertsId<T = any> = AssertsT1C<identity_2.URI, T>;

declare namespace AssertsT {
    export {
        getAsserts,
        AssertsT_2 as AssertsT,
        AssertsT2,
        AssertsT3,
        AssertsT1C,
        AssertsT2C,
        AssertsT3C,
        AssertsId,
        AssertError
    }
}
export { AssertsT }

// @public (undocumented)
type AssertsT1C<URI extends URIS, T> = {
    assert<A extends T>(a: unknown, msg?: string): asserts a is Kind<URI, A>;
    expect<A extends T>(value: unknown, isMatched: boolean, msg?: string): asserts value is Kind<URI, A>;
};

// @public (undocumented)
type AssertsT2<URI extends URIS2> = {
    assert<A, B>(a: unknown, msg?: string): asserts a is Kind2<URI, A, B>;
    expect<A, B>(value: unknown, isMatched: boolean, msg?: string): asserts value is Kind2<URI, A, B>;
};

// @public (undocumented)
type AssertsT2C<URI extends URIS2, T, T2> = {
    assert<A extends T, B extends T2>(a: unknown, msg?: string): asserts a is Kind2<URI, A, B>;
    expect<A extends T, B extends T2>(value: unknown, isMatched: boolean, msg?: string): asserts value is Kind2<URI, A, B>;
};

// @public (undocumented)
type AssertsT3<URI extends URIS3> = {
    assert<A, B, C>(a: unknown, msg?: string): asserts a is Kind3<URI, A, B, C>;
    expect<A, B, C>(value: unknown, isMatched: boolean, msg?: string): asserts value is Kind3<URI, A, B, C>;
};

// @public (undocumented)
type AssertsT3C<URI extends URIS3, T, T2, T3> = {
    assert<A extends T, B extends T2, C extends T3>(a: unknown, msg?: string): asserts a is Kind3<URI, A, B, C>;
    expect<A extends T, B extends T2, C extends T3>(value: unknown, isMatched: boolean, msg?: string): asserts value is Kind3<URI, A, B, C>;
};

// @public
type AssertsT_2<URI extends URIS> = {
    assert<A>(a: unknown, msg?: string): asserts a is Kind<URI, A>;
    expect<A>(value: any, isMatched: boolean, msg?: string): asserts value is Kind<URI, A>;
};

// @public (undocumented)
function capitalize<S extends string>(str: S): Capitalize<S>;

// @public (undocumented)
function getAsserts<M extends URIS3, A>(isMatched: Predicate<A>, URI: M): AssertsT3<M>;

// @public (undocumented)
function getAsserts<M extends URIS2, A>(isMatched: Predicate<A>, URI: M): AssertsT2<M>;

// @public (undocumented)
function getAsserts<M extends URIS, A, B extends A>(isMatched: Refinement<A, B>, URI: M): AssertsT1C<M, B>;

// @public (undocumented)
function getAsserts<M extends URIS, A>(isMatched: Predicate<A>, URI: M): AssertsT1C<M, A>;

// @public (undocumented)
function getAsserts<A>(isMatched: Predicate<A>, msg?: string): AssertsId<A>;

// @public (undocumented)
type Id = liftF11C<identity_2.URI, any>;

// @public (undocumented)
const Id: Id;

// @public (undocumented)
const Identity: LiftMap1<identity_2.URI>;

// @public (undocumented)
const IO: LiftMap1<MIO.URI>;

// @public (undocumented)
interface liftF11C<URI extends HKT.URIS, T> {
    // (undocumented)
    liftF1<A extends T, B extends T>(f: (a: A) => B): (a: HKT.Kind<URI, A>) => HKT.Kind<URI, B>;
    // (undocumented)
    liftF2<const A extends T, const B extends T, const C extends T>(f: (a: A, b: B) => C): (...args: MSeq<URI, [a: A, b: B]>) => HKT.Kind<URI, C>;
    // (undocumented)
    liftF3<A extends T, B extends T, C extends T, D extends T>(f: (a: A, b: B, c: C) => D): (a: HKT.Kind<URI, A>, b: HKT.Kind<URI, B>, c: HKT.Kind<URI, C>) => HKT.Kind<URI, D>;
    // (undocumented)
    liftF4<A extends T, B extends T, C extends T, D extends T, E extends T>(f: (a: A, b: B, c: C, d: D) => E): (...args: MSeq<URI, [a: A, b: B, c: C, d: D]>) => HKT.Kind<URI, E>;
}

declare namespace liftF1C {
    export {
        liftF1C_2 as liftF1C,
        liftF11C,
        Id
    }
}
export { liftF1C }

// @public (undocumented)
interface liftF1C_2<URI, T> {
    // (undocumented)
    liftF1<A extends T, B extends T>(f: (a: A) => B): (a: HKT.HKT<URI, A>) => HKT.HKT<URI, B>;
    // (undocumented)
    liftF2<A extends T, B extends T, C extends T>(f: (a: A, b: B) => C): (a: HKT.HKT<URI, A>, b: HKT.HKT<URI, B>) => HKT.HKT<URI, C>;
    // (undocumented)
    liftF3<A extends T, B extends T, C extends T, D extends T>(f: (a: A, b: B, c: C) => D): (a: HKT.HKT<URI, A>, b: HKT.HKT<URI, B>, c: HKT.HKT<URI, C>) => HKT.HKT<URI, D>;
    // (undocumented)
    liftF4<A extends T, B extends T, C extends T, D extends T, E extends T>(f: (a: A, b: B, c: C, d: D) => E): (a: HKT.HKT<URI, A>, b: HKT.HKT<URI, B>, c: HKT.HKT<URI, C>, d: HKT.HKT<URI, D>) => HKT.HKT<URI, E>;
}

declare namespace LiftMap {
    export {
        LiftMap2,
        LiftMap1,
        LiftMapT21,
        MSeq,
        MSeq2,
        LiftMapT22,
        IO,
        Identity,
        Reader
    }
}
export { LiftMap }

// @public (undocumented)
interface LiftMap1<URI extends URIS> extends Functor.Functor1<URI> {
    // (undocumented)
    liftMap<A, B, C>(fa: Kind<URI, A>, fb: Kind<URI, B>, f: (a: A, b: B) => C): Kind<URI, C>;
    // (undocumented)
    liftMap<A, B, C, D>(fa: Kind<URI, A>, fb: Kind<URI, B>, fc: Kind<URI, C>, f: (a: A, b: B, c: C) => D): Kind<URI, D>;
    // (undocumented)
    liftMap<A, B, C, D, E>(fa: Kind<URI, A>, fb: Kind<URI, B>, fc: Kind<URI, C>, fd: Kind<URI, D>, f: (a: A, b: B, c: C, d: D) => E): Kind<URI, E>;
    // (undocumented)
    liftMap<A, B, C, D, E, F>(fa: Kind<URI, A>, fb: Kind<URI, B>, fc: Kind<URI, C>, fd: Kind<URI, D>, fe: Kind<URI, E>, f: (a: A, b: B, c: C, d: D, e: E) => F): Kind<URI, F>;
    // (undocumented)
    liftMap<A, B, C, D, E, F, G>(fa: Kind<URI, A>, fb: Kind<URI, B>, fc: Kind<URI, C>, fd: Kind<URI, D>, fe: Kind<URI, E>, ff: Kind<URI, F>, f: (a: A, b: B, c: C, d: D, e: E, f: F) => G): Kind<URI, G>;
}

// @public (undocumented)
interface LiftMap2<URI extends URIS2> extends Functor.Functor2<URI> {
    // (undocumented)
    liftMap<I, A, B, C>(fa: Kind2<URI, I, A>, fb: Kind2<URI, I, B>, f: (a: A, b: B) => C): Kind2<URI, I, C>;
    // (undocumented)
    liftMap<I, A, B, C, D>(fa: Kind2<URI, I, A>, fb: Kind2<URI, I, B>, fc: Kind2<URI, I, C>, f: (a: A, b: B, c: C) => D): Kind2<URI, I, D>;
    // (undocumented)
    liftMap<I, A, B, C, D, E>(fa: Kind2<URI, I, A>, fb: Kind2<URI, I, B>, fc: Kind2<URI, I, C>, fd: Kind2<URI, I, D>, f: (a: A, b: B, c: C, d: D) => E): Kind2<URI, I, E>;
    // (undocumented)
    liftMap<I, A, B, C, D, E, F>(fa: Kind2<URI, I, A>, fb: Kind2<URI, I, B>, fc: Kind2<URI, I, C>, fd: Kind2<URI, I, D>, fe: Kind2<URI, I, E>, f: (a: A, b: B, c: C, d: D, e: E) => F): Kind2<URI, I, F>;
    // (undocumented)
    liftMap<I, A, B, C, D, E, F, G>(fa: Kind2<URI, I, A>, fb: Kind2<URI, I, B>, fc: Kind2<URI, I, C>, fd: Kind2<URI, I, D>, fe: Kind2<URI, I, E>, ff: Kind2<URI, I, F>, f: (a: A, b: B, c: C, d: D, e: E, f: F) => G): Kind2<URI, I, G>;
}

// @public (undocumented)
type LiftMapT21<MG extends URIS2, MF extends URIS> = {
    <I, A, B, C>(fa: Kind2<MG, I, Kind<MF, A>>, fb: Kind2<MG, I, Kind<MF, B>>, f: (a: A, b: B) => C): Kind2<MG, I, Kind<MF, C>>;
    <I, A, B, C, D>(fa: Kind2<MG, I, Kind<MF, A>>, fb: Kind2<MG, I, Kind<MF, B>>, fc: Kind2<MG, I, Kind<MF, C>>, f: (a: A, b: B, c: C) => D): Kind2<MG, I, Kind<MF, D>>;
    <I, A, B, C, D, E>(fa: Kind2<MG, I, Kind<MF, A>>, fb: Kind2<MG, I, Kind<MF, B>>, fc: Kind2<MG, I, Kind<MF, C>>, fd: Kind2<MG, I, Kind<MF, D>>, f: (a: A, b: B, c: C, d: D) => E): Kind2<MG, I, Kind<MF, E>>;
    <I, A, B, C, D, E, F>(fa: Kind2<MG, I, Kind<MF, A>>, fb: Kind2<MG, I, Kind<MF, B>>, fc: Kind2<MG, I, Kind<MF, C>>, fd: Kind2<MG, I, Kind<MF, D>>, fe: Kind2<MG, I, Kind<MF, E>>, f: (a: A, b: B, c: C, d: D, e: E) => F): Kind2<MG, I, Kind<MF, F>>;
    <I, A, B, C, D, E, F, G>(fa: Kind2<MG, I, Kind<MF, A>>, fb: Kind2<MG, I, Kind<MF, B>>, fc: Kind2<MG, I, Kind<MF, C>>, fd: Kind2<MG, I, Kind<MF, D>>, fe: Kind2<MG, I, Kind<MF, E>>, ff: Kind2<MG, I, Kind<MF, F>>, f: (a: A, b: B, c: C, d: D, e: E, f: F) => G): Kind2<MG, I, Kind<MF, G>>;
};

// @public (undocumented)
type LiftMapT22<MG extends URIS2, MF extends URIS2> = {
    <I, ER, A, B, C>(fa: Kind2<MG, I, Kind2<MF, ER, A>>, fb: Kind2<MG, I, Kind2<MF, ER, B>>, f: (a: A, b: B) => C): Kind2<MG, I, Kind2<MF, ER, C>>;
    <I, ER, A, B, C, D>(fa: Kind2<MG, I, Kind2<MF, ER, A>>, fb: Kind2<MG, I, Kind2<MF, ER, B>>, fc: Kind2<MG, I, Kind2<MF, ER, C>>, f: (a: A, b: B, c: C) => D): Kind2<MG, I, Kind2<MF, ER, D>>;
    <I, ER, A, B, C, D, E>(fa: Kind2<MG, I, Kind2<MF, ER, A>>, fb: Kind2<MG, I, Kind2<MF, ER, B>>, fc: Kind2<MG, I, Kind2<MF, ER, C>>, fd: Kind2<MG, I, Kind2<MF, ER, D>>, f: (a: A, b: B, c: C, d: D) => E): Kind2<MG, I, Kind2<MF, ER, E>>;
    <I, ER, A, B, C, D, E, F>(fa: Kind2<MG, I, Kind2<MF, ER, A>>, fb: Kind2<MG, I, Kind2<MF, ER, B>>, fc: Kind2<MG, I, Kind2<MF, ER, C>>, fd: Kind2<MG, I, Kind2<MF, ER, D>>, fe: Kind2<MG, I, Kind2<MF, ER, E>>, f: (a: A, b: B, c: C, d: D, e: E) => F): Kind2<MG, I, Kind2<MF, ER, F>>;
    <I, ER, A, B, C, D, E, F, G>(fa: Kind2<MG, I, Kind2<MF, ER, A>>, fb: Kind2<MG, I, Kind2<MF, ER, B>>, fc: Kind2<MG, I, Kind2<MF, ER, C>>, fd: Kind2<MG, I, Kind2<MF, ER, D>>, fe: Kind2<MG, I, Kind2<MF, ER, E>>, ff: Kind2<MG, I, Kind2<MF, ER, F>>, f: (a: A, b: B, c: C, d: D, e: E, f: F) => G): Kind2<MG, I, Kind2<MF, ER, G>>;
};

// @public (undocumented)
type MSeq<MF extends URIS, Args extends any[]> = {
    [Index in keyof Args]: Kind<MF, Args[Index]>;
};

// @public (undocumented)
type MSeq2<MF extends URIS2, E, Args extends any[]> = {
    [Index in keyof Args]: Kind2<MF, E, Args[Index]>;
};

declare namespace NonNullable_2 {
    export {
        predicate,
        Asserts
    }
}
export { NonNullable_2 as NonNullable }

// @public (undocumented)
const predicate: <T>(a: T) => a is NonNullable<T>;

// @public (undocumented)
const Reader: LiftMap2<MR.URI>;

// @public (undocumented)
const return1: typeof identity;

// @public (undocumented)
const return2: <B>(_a: any, b: B) => B;

// @public (undocumented)
const return3: <C>(_a: any, _b: any, c: C) => C;

// @public (undocumented)
const return4: <D>(_a: any, _b: any, _c: any, d: D) => D;

declare namespace tools {
    export {
        return1,
        return2,
        return3,
        return4,
        capitalize
    }
}
export { tools }

// (No @packageDocumentation comment for this package)

```
