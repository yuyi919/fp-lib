## API Report File for "@yuyi919/fp-lib"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as Eq from 'fp-ts/Eq';
import { Field } from 'fp-ts/Field';
import * as Functor from 'fp-ts/Functor';
import * as HKT from 'fp-ts/HKT';
import * as identity from 'fp-ts/Identity';
import { identity as identity_2 } from 'fp-ts/function';
import { Kind } from 'fp-ts/HKT';
import { Kind2 } from 'fp-ts/HKT';
import { Kind3 } from 'fp-ts/HKT';
import * as MIO from 'fp-ts/IO';
import * as Monad from 'fp-ts/Monad';
import { Monoid } from 'fp-ts/Monoid';
import * as MR from 'fp-ts/Reader';
import * as Ord from 'fp-ts/Ord';
import { Predicate } from 'fp-ts/Predicate';
import * as Predicate_2 from 'fp-ts/Predicate';
import * as R from 'fp-ts/Refinement';
import { Refinement } from 'fp-ts/Refinement';
import * as Ring from 'fp-ts/Ring';
import * as Semigroup from 'fp-ts/Semigroup';
import * as Semiring from 'fp-ts/Semiring';
import { URIS } from 'fp-ts/HKT';
import { URIS2 } from 'fp-ts/HKT';
import { URIS3 } from 'fp-ts/HKT';

// @public (undocumented)
type AnyNewtype = INewtype<any, any>;

// @public (undocumented)
class AssertError extends Error {
    constructor(msg?: string);
}

// @public (undocumented)
const Asserts: AssertsT.AssertsT<"NonNullable">;

// @public (undocumented)
type AssertsId<T = any> = AssertsT1C<identity.URI, T>;

declare namespace AssertsT {
    export {
        getAsserts,
        AssertsT_2 as AssertsT,
        AssertsT2,
        AssertsT3,
        AssertsT1C,
        AssertsT2C,
        AssertsT3C,
        AssertsId,
        AssertError
    }
}
export { AssertsT }

// @public (undocumented)
type AssertsT1C<URI extends URIS, T> = {
    assert<A extends T>(a: unknown, msg?: string): asserts a is Kind<URI, A>;
    expect<A extends T>(value: unknown, isMatched: boolean, msg?: string): asserts value is Kind<URI, A>;
};

// @public (undocumented)
type AssertsT2<URI extends URIS2> = {
    assert<A, B>(a: unknown, msg?: string): asserts a is Kind2<URI, A, B>;
    expect<A, B>(value: unknown, isMatched: boolean, msg?: string): asserts value is Kind2<URI, A, B>;
};

// @public (undocumented)
type AssertsT2C<URI extends URIS2, T, T2> = {
    assert<A extends T, B extends T2>(a: unknown, msg?: string): asserts a is Kind2<URI, A, B>;
    expect<A extends T, B extends T2>(value: unknown, isMatched: boolean, msg?: string): asserts value is Kind2<URI, A, B>;
};

// @public (undocumented)
type AssertsT3<URI extends URIS3> = {
    assert<A, B, C>(a: unknown, msg?: string): asserts a is Kind3<URI, A, B, C>;
    expect<A, B, C>(value: unknown, isMatched: boolean, msg?: string): asserts value is Kind3<URI, A, B, C>;
};

// @public (undocumented)
type AssertsT3C<URI extends URIS3, T, T2, T3> = {
    assert<A extends T, B extends T2, C extends T3>(a: unknown, msg?: string): asserts a is Kind3<URI, A, B, C>;
    expect<A extends T, B extends T2, C extends T3>(value: unknown, isMatched: boolean, msg?: string): asserts value is Kind3<URI, A, B, C>;
};

// @public (undocumented)
type AssertsT_2<URI extends URIS> = {
    assert<A>(a: unknown, msg?: string): asserts a is Kind<URI, A>;
    expect<A>(value: any, isMatched: boolean, msg?: string): asserts value is Kind<URI, A>;
};

// @public (undocumented)
function capitalize<S extends string>(str: S): Capitalize<S>;

// @public (undocumented)
type CarrierOf<N extends AnyNewtype> = N extends INewtype<any, infer A> ? A : never;

// @public (undocumented)
type Concat<N1 extends INewtype<object, any>, N2 extends INewtype<object, CarrierOf<N1>>> = INewtype<URIOf<N1> & URIOf<N2>, CarrierOf<N1>>;

// @public (undocumented)
function define<URI extends Newtypes.TypeURIS, T>(guard: Newtypes.Guard<URI, T>["guard"], URI: Newtypes.Guard<URI, T>["URI"]): INewtypeURI<URI, Newtypes.Kind<URI, T>, CarrierOf<Newtypes.Kind<URI, T>>>;

// @public (undocumented)
function define<S extends AnyNewtype>(predicate: Predicate_2.Predicate<CarrierOf<S>>, message?: string): INewtypeClass<S, CarrierOf<S>>;

// @public (undocumented)
function define<S extends AnyNewtype, A extends CarrierOf<S> = CarrierOf<S>>(predicate?: Predicate_2.Predicate<A>): INewtypeClass<S, A>;

// @public (undocumented)
type Extends<N extends AnyNewtype, Tags extends object> = INewtype<Tags & URIOf<N>, CarrierOf<N>>;

// @public (undocumented)
function getAsserts<M extends URIS3, A>(isMatched: Predicate<A>, URI: M): AssertsT3<M>;

// @public (undocumented)
function getAsserts<M extends URIS2, A>(isMatched: Predicate<A>, URI: M): AssertsT2<M>;

// @public (undocumented)
function getAsserts<M extends URIS, A, B extends A>(isMatched: Refinement<A, B>, URI: M): AssertsT1C<M, B>;

// @public (undocumented)
function getAsserts<M extends URIS, A>(isMatched: Predicate<A>, URI: M): AssertsT1C<M, A>;

// @public (undocumented)
function getAsserts<A>(isMatched: Predicate<A>, msg?: string): AssertsId<A>;

// @public (undocumented)
function getAsserts_2<S extends AnyNewtype>(R: INewtypeProto<S, any>): AssertsT.AssertsId<S>;

// @public (undocumented)
const getEq: <S extends AnyNewtype>(S: Eq.Eq<CarrierOf<S>>) => Eq.Eq<S>;

// @public (undocumented)
const getField: <S extends AnyNewtype>(F: Field<CarrierOf<S>>) => Field<S>;

// @public (undocumented)
const getFunctor: <S extends AnyNewtype>(S: Functor.Functor<CarrierOf<S>>) => Functor.Functor<S>;

// @public (undocumented)
const getMonoid: <S extends AnyNewtype>(M: Monoid<CarrierOf<S>>) => Monoid<S>;

// @public (undocumented)
const getOrd: <S extends AnyNewtype>(O: Ord.Ord<CarrierOf<S>>) => Ord.Ord<S>;

// @public (undocumented)
const getPrediates: Id;

// @public (undocumented)
const getRing: <S extends AnyNewtype>(R: Ring.Ring<CarrierOf<S>>) => Ring.Ring<S>;

// @public (undocumented)
const getSemigroup: <S extends AnyNewtype>(S: Semigroup.Semigroup<CarrierOf<S>>) => Semigroup.Semigroup<S>;

// @public (undocumented)
const getSemiring: <S extends AnyNewtype>(S: Semiring.Semiring<CarrierOf<S>>) => Semiring.Semiring<S>;

// @public (undocumented)
type Id = liftF11C<identity.URI, any>;

// @public (undocumented)
const Id: Id;

// @public (undocumented)
const Identity: LiftMap1<identity.URI>;

// @public (undocumented)
interface IGuardNewType<URI extends Newtypes.TypeURIS, S extends AnyNewtype, T extends CarrierOf<S>> extends INewtypeProtoURI<URI, S, T> {
    // (undocumented)
    <const A extends T>(input: A, unsafeCoerce: true): Newtypes.GuardResult<URI, A>;
    // (undocumented)
    <A extends T>(a: Newtypes.InputGuard<URI, A>, unsafeCoerce?: false): Newtypes.GuardResult<URI, A>;
}

// @public (undocumented)
interface INewtype<URI, A> {
    // (undocumented)
    readonly [newtypeId]: typeof newtypeId;
    // (undocumented)
    readonly _A: A;
    // (undocumented)
    readonly _URI: URI;
}

// @public (undocumented)
interface INewtypeClass<S extends AnyNewtype, T extends CarrierOf<S>> extends INewtypeProto<S, T> {
    // (undocumented)
    (input: T, unsafeCoerce?: boolean): S;
    // (undocumented)
    lift: Functor.Functor<URIOf<S>>["map"];
    // (undocumented)
    liftF1: liftF1C.liftF1C<URIOf<S>, T>["liftF1"];
    // (undocumented)
    liftF2: liftF1C.liftF1C<URIOf<S>, T>["liftF2"];
    // (undocumented)
    liftF3: liftF1C.liftF1C<URIOf<S>, T>["liftF3"];
    // (undocumented)
    Monad: Monad.Monad<URIOf<S>>;
}

// @public (undocumented)
interface INewtypeProto<S extends AnyNewtype, T extends CarrierOf<S>> {
    // (undocumented)
    is: R.Refinement<any, S>;
    // (undocumented)
    msg: string;
    // (undocumented)
    predicate: Predicate_2.Predicate<CarrierOf<S>>;
    // (undocumented)
    unsafe(a: T): S;
    // (undocumented)
    unwrap(a: S): T;
}

// @public (undocumented)
interface INewtypeProtoURI<URI extends Newtypes.TypeURIS, S extends AnyNewtype, T extends CarrierOf<S>> extends INewtypeProto<S, T> {
    // (undocumented)
    lift: Functor.Functor1<URI>["map"];
    // (undocumented)
    liftF1: liftF1C.liftF11C<URI, T>["liftF1"];
    // (undocumented)
    liftF2: liftF1C.liftF11C<URI, T>["liftF2"];
    // (undocumented)
    liftF3: liftF1C.liftF11C<URI, T>["liftF3"];
    // (undocumented)
    Monad: Monad.Monad1<URI>;
}

// @public (undocumented)
interface INewtypeURI<URI extends Newtypes.TypeURIS, S extends AnyNewtype, T extends CarrierOf<S>> extends INewtypeProtoURI<URI, S, T> {
    // (undocumented)
    <const A extends T>(a: Newtypes.InputGuard<URI, A>, unsafeCoerce?: false): Newtypes.Kind<URI, A>;
    // (undocumented)
    <const A extends T>(input: A, unsafeCoerce: true): Newtypes.Kind<URI, A>;
}

// @public (undocumented)
const IO: LiftMap1<MIO.URI>;

// @public (undocumented)
interface liftF11C<URI extends HKT.URIS, T> {
    // (undocumented)
    liftF1<A extends T, B extends T>(f: (a: A) => B): (a: HKT.Kind<URI, A>) => HKT.Kind<URI, B>;
    // (undocumented)
    liftF2<const A extends T, const B extends T, const C extends T>(f: (a: A, b: B) => C): (...args: MSeq<URI, [a: A, b: B]>) => HKT.Kind<URI, C>;
    // (undocumented)
    liftF3<A extends T, B extends T, C extends T, D extends T>(f: (a: A, b: B, c: C) => D): (a: HKT.Kind<URI, A>, b: HKT.Kind<URI, B>, c: HKT.Kind<URI, C>) => HKT.Kind<URI, D>;
    // (undocumented)
    liftF4<A extends T, B extends T, C extends T, D extends T, E extends T>(f: (a: A, b: B, c: C, d: D) => E): (...args: MSeq<URI, [a: A, b: B, c: C, d: D]>) => HKT.Kind<URI, E>;
}

declare namespace liftF1C {
    export {
        liftF1C_2 as liftF1C,
        liftF11C,
        Id,
        getPrediates
    }
}
export { liftF1C }

// @public (undocumented)
interface liftF1C_2<URI, T> {
    // (undocumented)
    liftF1<A extends T, B extends T>(f: (a: A) => B): (a: HKT.HKT<URI, A>) => HKT.HKT<URI, B>;
    // (undocumented)
    liftF2<A extends T, B extends T, C extends T>(f: (a: A, b: B) => C): (a: HKT.HKT<URI, A>, b: HKT.HKT<URI, B>) => HKT.HKT<URI, C>;
    // (undocumented)
    liftF3<A extends T, B extends T, C extends T, D extends T>(f: (a: A, b: B, c: C) => D): (a: HKT.HKT<URI, A>, b: HKT.HKT<URI, B>, c: HKT.HKT<URI, C>) => HKT.HKT<URI, D>;
    // (undocumented)
    liftF4<A extends T, B extends T, C extends T, D extends T, E extends T>(f: (a: A, b: B, c: C, d: D) => E): (a: HKT.HKT<URI, A>, b: HKT.HKT<URI, B>, c: HKT.HKT<URI, C>, d: HKT.HKT<URI, D>) => HKT.HKT<URI, E>;
}

declare namespace LiftMap {
    export {
        LiftMap2,
        LiftMap1,
        LiftMapT21,
        MSeq,
        MSeq2,
        LiftMapT22,
        IO,
        Identity,
        Reader
    }
}
export { LiftMap }

// @public (undocumented)
interface LiftMap1<URI extends URIS> extends Functor.Functor1<URI> {
    // (undocumented)
    liftMap<A, B, C>(fa: Kind<URI, A>, fb: Kind<URI, B>, f: (a: A, b: B) => C): Kind<URI, C>;
    // (undocumented)
    liftMap<A, B, C, D>(fa: Kind<URI, A>, fb: Kind<URI, B>, fc: Kind<URI, C>, f: (a: A, b: B, c: C) => D): Kind<URI, D>;
    // (undocumented)
    liftMap<A, B, C, D, E>(fa: Kind<URI, A>, fb: Kind<URI, B>, fc: Kind<URI, C>, fd: Kind<URI, D>, f: (a: A, b: B, c: C, d: D) => E): Kind<URI, E>;
    // (undocumented)
    liftMap<A, B, C, D, E, F>(fa: Kind<URI, A>, fb: Kind<URI, B>, fc: Kind<URI, C>, fd: Kind<URI, D>, fe: Kind<URI, E>, f: (a: A, b: B, c: C, d: D, e: E) => F): Kind<URI, F>;
    // (undocumented)
    liftMap<A, B, C, D, E, F, G>(fa: Kind<URI, A>, fb: Kind<URI, B>, fc: Kind<URI, C>, fd: Kind<URI, D>, fe: Kind<URI, E>, ff: Kind<URI, F>, f: (a: A, b: B, c: C, d: D, e: E, f: F) => G): Kind<URI, G>;
}

// @public (undocumented)
interface LiftMap2<URI extends URIS2> extends Functor.Functor2<URI> {
    // (undocumented)
    liftMap<I, A, B, C>(fa: Kind2<URI, I, A>, fb: Kind2<URI, I, B>, f: (a: A, b: B) => C): Kind2<URI, I, C>;
    // (undocumented)
    liftMap<I, A, B, C, D>(fa: Kind2<URI, I, A>, fb: Kind2<URI, I, B>, fc: Kind2<URI, I, C>, f: (a: A, b: B, c: C) => D): Kind2<URI, I, D>;
    // (undocumented)
    liftMap<I, A, B, C, D, E>(fa: Kind2<URI, I, A>, fb: Kind2<URI, I, B>, fc: Kind2<URI, I, C>, fd: Kind2<URI, I, D>, f: (a: A, b: B, c: C, d: D) => E): Kind2<URI, I, E>;
    // (undocumented)
    liftMap<I, A, B, C, D, E, F>(fa: Kind2<URI, I, A>, fb: Kind2<URI, I, B>, fc: Kind2<URI, I, C>, fd: Kind2<URI, I, D>, fe: Kind2<URI, I, E>, f: (a: A, b: B, c: C, d: D, e: E) => F): Kind2<URI, I, F>;
    // (undocumented)
    liftMap<I, A, B, C, D, E, F, G>(fa: Kind2<URI, I, A>, fb: Kind2<URI, I, B>, fc: Kind2<URI, I, C>, fd: Kind2<URI, I, D>, fe: Kind2<URI, I, E>, ff: Kind2<URI, I, F>, f: (a: A, b: B, c: C, d: D, e: E, f: F) => G): Kind2<URI, I, G>;
}

// @public (undocumented)
type LiftMapT21<MG extends URIS2, MF extends URIS> = {
    <I, A, B, C>(fa: Kind2<MG, I, Kind<MF, A>>, fb: Kind2<MG, I, Kind<MF, B>>, f: (a: A, b: B) => C): Kind2<MG, I, Kind<MF, C>>;
    <I, A, B, C, D>(fa: Kind2<MG, I, Kind<MF, A>>, fb: Kind2<MG, I, Kind<MF, B>>, fc: Kind2<MG, I, Kind<MF, C>>, f: (a: A, b: B, c: C) => D): Kind2<MG, I, Kind<MF, D>>;
    <I, A, B, C, D, E>(fa: Kind2<MG, I, Kind<MF, A>>, fb: Kind2<MG, I, Kind<MF, B>>, fc: Kind2<MG, I, Kind<MF, C>>, fd: Kind2<MG, I, Kind<MF, D>>, f: (a: A, b: B, c: C, d: D) => E): Kind2<MG, I, Kind<MF, E>>;
    <I, A, B, C, D, E, F>(fa: Kind2<MG, I, Kind<MF, A>>, fb: Kind2<MG, I, Kind<MF, B>>, fc: Kind2<MG, I, Kind<MF, C>>, fd: Kind2<MG, I, Kind<MF, D>>, fe: Kind2<MG, I, Kind<MF, E>>, f: (a: A, b: B, c: C, d: D, e: E) => F): Kind2<MG, I, Kind<MF, F>>;
    <I, A, B, C, D, E, F, G>(fa: Kind2<MG, I, Kind<MF, A>>, fb: Kind2<MG, I, Kind<MF, B>>, fc: Kind2<MG, I, Kind<MF, C>>, fd: Kind2<MG, I, Kind<MF, D>>, fe: Kind2<MG, I, Kind<MF, E>>, ff: Kind2<MG, I, Kind<MF, F>>, f: (a: A, b: B, c: C, d: D, e: E, f: F) => G): Kind2<MG, I, Kind<MF, G>>;
};

// @public (undocumented)
type LiftMapT22<MG extends URIS2, MF extends URIS2> = {
    <I, ER, A, B, C>(fa: Kind2<MG, I, Kind2<MF, ER, A>>, fb: Kind2<MG, I, Kind2<MF, ER, B>>, f: (a: A, b: B) => C): Kind2<MG, I, Kind2<MF, ER, C>>;
    <I, ER, A, B, C, D>(fa: Kind2<MG, I, Kind2<MF, ER, A>>, fb: Kind2<MG, I, Kind2<MF, ER, B>>, fc: Kind2<MG, I, Kind2<MF, ER, C>>, f: (a: A, b: B, c: C) => D): Kind2<MG, I, Kind2<MF, ER, D>>;
    <I, ER, A, B, C, D, E>(fa: Kind2<MG, I, Kind2<MF, ER, A>>, fb: Kind2<MG, I, Kind2<MF, ER, B>>, fc: Kind2<MG, I, Kind2<MF, ER, C>>, fd: Kind2<MG, I, Kind2<MF, ER, D>>, f: (a: A, b: B, c: C, d: D) => E): Kind2<MG, I, Kind2<MF, ER, E>>;
    <I, ER, A, B, C, D, E, F>(fa: Kind2<MG, I, Kind2<MF, ER, A>>, fb: Kind2<MG, I, Kind2<MF, ER, B>>, fc: Kind2<MG, I, Kind2<MF, ER, C>>, fd: Kind2<MG, I, Kind2<MF, ER, D>>, fe: Kind2<MG, I, Kind2<MF, ER, E>>, f: (a: A, b: B, c: C, d: D, e: E) => F): Kind2<MG, I, Kind2<MF, ER, F>>;
    <I, ER, A, B, C, D, E, F, G>(fa: Kind2<MG, I, Kind2<MF, ER, A>>, fb: Kind2<MG, I, Kind2<MF, ER, B>>, fc: Kind2<MG, I, Kind2<MF, ER, C>>, fd: Kind2<MG, I, Kind2<MF, ER, D>>, fe: Kind2<MG, I, Kind2<MF, ER, E>>, ff: Kind2<MG, I, Kind2<MF, ER, F>>, f: (a: A, b: B, c: C, d: D, e: E, f: F) => G): Kind2<MG, I, Kind2<MF, ER, G>>;
};

// @public (undocumented)
type MSeq<MF extends URIS, Args extends any[]> = {
    [Index in keyof Args]: Kind<MF, Args[Index]>;
};

// @public (undocumented)
type MSeq2<MF extends URIS2, E, Args extends any[]> = {
    [Index in keyof Args]: Kind2<MF, E, Args[Index]>;
};

declare namespace Newtype {
    export {
        getAsserts_2 as getAsserts,
        define,
        newtypeId,
        INewtype,
        Newtype_2 as Newtype,
        AnyNewtype,
        URIOf,
        CarrierOf,
        getEq,
        getFunctor,
        getOrd,
        getSemigroup,
        getMonoid,
        getSemiring,
        getRing,
        getField,
        INewtypeProto,
        INewtypeClass,
        INewtypeProtoURI,
        INewtypeURI,
        IGuardNewType,
        Concat,
        Extends
    }
}
export { Newtype }

// @public (undocumented)
type Newtype_2<URI extends string, A = any> = INewtype<{
    readonly [K in URI]: K;
}, A>;

// @public (undocumented)
const newtypeId: unique symbol;

declare namespace NonNullable_2 {
    export {
        predicate,
        Asserts
    }
}
export { NonNullable_2 as NonNullable }

// @public (undocumented)
const predicate: <T>(a: T) => a is NonNullable<T>;

// @public (undocumented)
const Reader: LiftMap2<MR.URI>;

// @public (undocumented)
const return1: typeof identity_2;

// @public (undocumented)
const return2: <B>(_a: any, b: B) => B;

// @public (undocumented)
const return3: <C>(_a: any, _b: any, c: C) => C;

// @public (undocumented)
const return4: <D>(_a: any, _b: any, _c: any, d: D) => D;

declare namespace tools {
    export {
        return1,
        return2,
        return3,
        return4,
        capitalize
    }
}
export { tools }

// @public (undocumented)
type URIOf<N extends AnyNewtype> = N extends INewtype<infer URI, any> ? URI : never;

// (No @packageDocumentation comment for this package)

```
